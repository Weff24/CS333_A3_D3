<html>
<!DOCTYPE html>
<meta charset="utf-8">
<style>
  #world_map {
    border: solid 1px black;
    flex: 1;
  }

  .states {
    fill: #ccc;
    stroke: #fff;
  }

  .symbol {
    fill-opacity: .8;
    stroke: #fff;
  }

  .symbol:hover {
    fill: red;
  }

  div.tooltip {
    display: grid;
    align-content: center;
    position: absolute;
    text-align: center;
    width: 200px;
    height: 60px;
    font: 12px sans-serif;
    background: lightsteelblue;
    border: 0px;
    pointer-events: none;
  }
</style>

<body>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>

  <div id="vis_container">
    <div>
      <tr>
        <td>
          <input type="Button" value="Clear Selections" onclick="resetSelection()" />
        </td>
      </tr>
    </div>

    <div>
      <svg id="world_map" width="800" height="350"></svg>
    </div>
    <div style="position: relative;">
      <svg id="population_plot" class="brush_container" width="800" height="600">
        <rect
        rx="4"
        ry="4"
        x="0"
        y="0"
        width="0"
        height="0"
        class="selection-rect"
        style="fill: rgba(185, 177, 177, 0.25); stroke: rgb(82, 82, 82); stroke-width: 2.5;"
    > 
  </rect>
      </svg>
      <!-- <svg id="selection_box" width="1000" height="1000" style="position: absolute; top: 0; left: 0;" >
        
    </svg> -->
    </div>
    <div>
      <svg id="scat_plot" width="800" height="350"></svg>
      
    </div>
  </div>

  <script>
    // The svg
    let svg = d3.select("#world_map");
    let width = +svg.attr("width");
    let height = +svg.attr("height");

    // Map and projection
    let path = d3.geoPath();
    let projection = d3.geoMercator()
      .scale(70)
      .center([0, 0]);
    // .translate([-width / 2, 0]);

    // Data and color scale
    let countriesData = {}
    let data = d3.map();
    let colorScale = d3.scaleThreshold()
      .domain([100000, 1000000, 10000000, 30000000, 100000000, 500000000])
      .range(d3.schemeBlues[7]);

    // Colors 
    let selectedColor = "#f25050";
    let unselectedColor = "#ECECEC";
    let hoverColor = "#2986CC";
    let dotColor = "#B5B5B5";
    let borderColor = "#3F3F3F";

    // Selected data
    let selectedCountries = [];

    // basic tooltip
    let tooltip = d3.select("body").append("div")
      .attr("class", "tooltip")
      .style("opacity", 0);

    // let countryCoordinatesAlt = d3.map();


    // Load external data and boot
    d3.queue()
      .defer(d3.json, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson")
      // .defer(d3.csv, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world_population.csv", function (d) { data.set(d.code, +d.pop); })
      .defer(d3.csv, "countries of the world very very clean.csv", function (d) {
        let countryNames = d["Country"].replace(/[$"]|\s+$/g, "").trim()
        let countryAltNames = d["Country_cleaned_name"].replace(/[$"]|\s+$/g, "").trim()

        countriesData[countryAltNames] = d;
      })
      .await(ready);

    let drawMap = null;
    let drawPopulationPlot = null;
    let colorPlot = null;
    let brushPopulation = this.brush;

    let resetSelection = () => {
      selectedCountries = [];

      d3.selectAll(".selection").style("display", "none");

      colorPlot();
      drawMap();
      drawPopulationPlot();
    }

    function ready(error, topojson) {

      let mouseOver = function (d) {

        tooltip.transition()
          .duration(200)
          .style("opacity", .9)
          .style("left", event.pageX + "px")
          .style("top", (event.pageY + 10) + "px");
        if (Object.keys(countriesData).includes(d.properties.name)) {
          tooltip.html(d.properties.name
            + "<br>Population: " + countriesData[d.properties.name]["Population"]
            + "<br>GDP Per Capita: $" + countriesData[d.properties.name]["GDP ($ per capita)"]
            + "<br>Literacy Rate: " + countriesData[d.properties.name]["Literacy (%)"].replace(",", ".") + "%");
        } else {
          tooltip.html(d.properties.name + "<br>No data (Country not in dataset)");
        }


        d3.selectAll(".Country")
          .transition()
          .duration(100)
          .style("fill", function (country) {
            return selectedCountries.includes(country.properties.name) ? selectedColor : unselectedColor;
          })
        d3.select(this)
          .transition()
          .duration(100)
          .style("fill", hoverColor)
      };

      let mouseLeave = function (d) {

        // Hide the tooltip 
        tooltip.transition()
          .duration(200)
          .style("opacity", 0);

        d3.selectAll(".Country")
          .transition()
          .duration(100)
          .style("fill", function (country) {
            return selectedCountries.includes(country.properties.name) ? selectedColor : unselectedColor;
          })

        d3.select(this)
          .transition()
          .duration(100)
          .style("fill", function (country) {
            return selectedCountries.includes(country.properties.name) ? selectedColor : unselectedColor;
          })
      };

      let mouseClick = function (d) {
        // Store the name of the selected country
        if (selectedCountries.includes(d.properties.name)) {
          // Remove the country from the list
          selectedCountries = selectedCountries.filter(country => country !== d.properties.name);
        } else {
          // Add the country to the list
          selectedCountries.push(d.properties.name);
        }

        // Reset the color of all countries
        d3.selectAll(".Country")
          .transition()
          .duration(100)
          .style("fill", function (country) {
            return selectedCountries.includes(country.properties.name) ? selectedColor : unselectedColor;
          })

        d3.select(this)
          .transition()
          .duration(100)
          .style("fill", function (country) {
            return selectedCountries.includes(country.properties.name) ? selectedColor : hoverColor;
          })

        colorPlot();
      };


      // Draw the map
      drawMap = () => {
        svg.select('g').remove();

        svg.append("g")
          .selectAll("path")
          .data(topojson.features)
          .enter()
          .append("path")
          // draw each country
          .attr("d", d3.geoPath()
            .projection(projection)
          )
          // set the color of each country
          .style("fill", unselectedColor)
          .style("stroke", borderColor)
          .attr("class", function (d) { return "Country" })
          .on("mouseover", mouseOver)
          .on("mouseleave", mouseLeave)
          .on("click", mouseClick);

        let zoom = d3.zoom()
          .scaleExtent([1, 12])
          .translateExtent([[0, 0], [width, height]])
          .on('zoom', () => {
            svg.selectAll('path').attr('transform', d3.event.transform);
            svg.attr('stroke-width', 1 / d3.event.transform.k);
          });
        svg.transition().duration(1000).call(zoom.transform, d3.zoomIdentity);
        svg.call(zoom);
      }

      // Draw population plot function
      let widthPlot = 800;
      let heightPlot = 750;
      
      let marginTop = 0;
      let marginRight = 20;
      let marginBottom = 20;
      let marginLeft = 20;
      let radius = 4;
      let padding = 2;
      let xScalePopulation = d3.scaleLog()
        .domain(d3.extent(Object.values(countriesData).map(d => +d["Population"])))
        .range([marginLeft, width - marginRight]);

      drawPopulationPlot = () => {
        let svg2 = d3.select("#population_plot")
          .attr("width", widthPlot)
          .attr("height", heightPlot)
          .attr("transform", `translate(0,${marginTop})`)
          .attr("viewBox", [0, 600, widthPlot, heightPlot])
          .attr("style", "max-width: 100%; height: auto;");

        svg2.append("g")
          .attr("transform", `translate(0,${heightPlot - marginBottom})`)
          .call(d3.axisBottom(xScalePopulation).ticks(5, ",.0f").tickSize(10));

        // Append x-axis label
        svg2.append("text")
          .attr("transform", `translate(${widthPlot / 2},${heightPlot + 20})`) // Adjust the position as needed
          .style("text-anchor", "middle")
          .text("Population");

        // Append title
        svg2.append("text")
          .attr("x", widthPlot / 2)
          .attr("y", `${heightPlot + 50}`) // Adjust the position as needed
          .style("font-size", "20px")
          .style("font-weight", "bold")
          .style("text-anchor", "middle")
          .text("Population Distribution by Country");

        svg2.append("g")
          .selectAll("dot")
          .data(dodge(Object.values(countriesData), { radius: radius * 2 + padding, x: d => xScalePopulation(d["Population"]) }))
          .enter()
          .append("circle")
          .attr("cx", d => d.x)
          .attr("cy", d => heightPlot - marginBottom - radius - padding - d.y)
          .attr("r", radius)
          .attr("fill", dotColor);
        
          // this stuff is what makes the population plot listen for dragging from the mouse
          svg2.call(d3.drag()
                .on("start", dragStart)
                .on("drag", dragMove)
                .on("end", dragEnd));
                
        function dodge(data, { radius = 1, x }) {
          const radius2 = radius ** 2;
          const circles = data.map((d, i, data) => ({ x: +xScalePopulation(d["Population"]), data: d })).sort((a, b) => a.x - b.x);
          // circles.forEach(circle => {
          //   console.log(circle);
          // });
          const epsilon = 1e-3;
          let head = null, tail = null;

          // Returns true if circle ⟨x,y⟩ intersects with any circle in the queue.
          function intersects(x, y) {
            let a = head;
            while (a) {
              if (radius2 - epsilon > (a.x - x) ** 2 + (a.y - y) ** 2) {
                return true;
              }
              a = a.next;
            }
            return false;
          }

          // Place each circle sequentially.
          for (const b of circles) {
            // Remove circles from the queue that can’t intersect the new circle b.
            while (head && head.x < b.x - radius2) head = head.next;

            // Choose the minimum non-intersecting tangent.
            if (intersects(b.x, b.y = 0)) {
              let a = head;
              b.y = Infinity;
              do {
                let y = a.y + Math.sqrt(radius2 - (a.x - b.x) ** 2);
                if (y < b.y && !intersects(b.x, y)) b.y = y;
                a = a.next;
              } while (a);
            }

            // Add b to the queue.
            b.next = null;
            if (head === null) head = tail = b;
            else tail = tail.next = b;
          }
          return circles;
        }
      }

      // Draw map and plots
      drawMap();
      drawPopulationPlot();


      // 
      // Brushing and Linking
      //

        // Declare rectElement outside the function
        var rectElement;

        var selectionRect = {
            element: null,
            originX: 0,
            originY: 0,

            setElement: function(ele) {
                this.element = ele;
            },

            init: function(newX, newY, xAxisOnly) {
                this.setElement(rectElement);
                this.originX = newX;
                this.originY = newY;
                this.update(newX, newY, xAxisOnly);
            },

            update: function(newX, newY, xAxisOnly) {
                this.currentX = newX;
                this.currentY = newY;

                var x = Math.min(this.currentX, this.originX);
                var y = Math.min(this.currentY, this.originY);
                var width = Math.abs(this.currentX - this.originX);
                var height = Math.abs(this.currentY - this.originY);

                // Set properties of the rectElement directly
                rectElement.attr("x", x);
                rectElement.attr("width", width);

                if (xAxisOnly) {
                    // If only the X-axis is used, set a fixed height
                    rectElement.attr("y", 600); // currently hard-coded in
                    rectElement.attr("height", 130); // currently hard-coded in
                } else {
                    // If both axes are used, update the width and height
                    rectElement.attr("y", y);
                    rectElement.attr("height", height);
                }
            },

            remove: function() {
                // No need to remove the rectElement since it's not created dynamically
                this.element = null;
            }
        };

        function dragStart() {
            //console.log("dragStart");
            var p = d3.mouse(this);
            selectionRect.init(p[0], p[1], true);
        }
        
        // Initialize a Map to store country names and their corresponding x-values
        let countryXMap = new Map();

        // Populate the countryXMap during the data loading phase
        Object.values(countriesData).forEach(function (country) {
          var countryName = country["Country_cleaned_name"].replace(/[$"]|\s+$/g, "").trim();
          var xValue = xScalePopulation(country["Population"]);
          countryXMap.set(countryName, xValue);
        });

        function dragMove() {
          
            var p = d3.mouse(this);

            // Update the selection box
            selectionRect.update(p[0], p[1], true);

            // Get the x-range of the selection box
            var xMin = Math.min(selectionRect.originX, selectionRect.currentX);
            var xMax = Math.max(selectionRect.originX, selectionRect.currentX);

            // Filter countries based on the x-range
            var selectedCountriesInBox = Object.values(countriesData).filter(function (country) {
                var x = xScalePopulation(country["Population"]);
                return x >= xMin && x <= xMax;
            });

            // Update selectedCountries array
            selectedCountries = selectedCountriesInBox.map(function (country) {
                return country["Country_cleaned_name"].replace(/[$"]|\s+$/g, "").trim();
            });

            //console.log(selectedCountries);
            
            // Update the color based on the selection
            colorMap();
            colorPlot();
            // drawMap();
        }

        function dragEnd() {
            console.log("dragEnd");
        }

        
        function handlePlotMouseover(d) {
        // Show tooltip on mouseover
        tooltip.transition()
          .duration(200)
          .style("opacity", .9)
          .style("left", event.pageX + "px")
          .style("top", (event.pageY + 10) + "px");

          tooltip.html(d['data']['Country_cleaned_name']
            + "<br>Population: " + d['data']["Population"]);

            
          d3.select(this)
          .transition()
          .duration(100)
          .style("fill", function (country) {
            return hoverColor;
          })


        }

        function handlePlotMouseleave() {
        // Hide tooltip on mouseleave
        tooltip.transition()
            .duration(200)
            .style("opacity", 0);

        d3.select(this)
          .transition()
          .duration(100)
          .style("fill", function (country) {
            console.log((selectedCountries.includes(d3.select(this).data()[0]['data']['Country_cleaned_name'].replace(/[$"]|\s+$/g, "").trim())));
            console.log(selectedCountries)
            console.log(d3.select(this).data()[0]['data']['Country_cleaned_name'].replace(/[$"]|\s+$/g, "").trim())
            // if selected countries includes the country just left, then change the color back to selectedColor, else dotColor
            return (selectedCountries.includes(d3.select(this).data()[0]['data']['Country_cleaned_name'].replace(/[$"]|\s+$/g, "").trim())) ? selectedColor : dotColor;
          })

        }

        function displayRect() {
            // Select the rect element inside #selection_box
            rectElement = d3.select("#population_plot rect");

            if (rectElement.empty()) {
                console.error("No rect element found inside #population_plot");
                return;
            }

            // Attach drag behavior to the existing rectElement
            rectElement
                .call(d3.drag().on("start", dragStart).on("drag", dragMove).on("end", dragEnd));

            // Set the rectElement to be the target for selectionRect
            selectionRect.setElement(rectElement);
        }

        // Call the displayRect function to initiate the rectangle
        displayRect();

        d3.selectAll("circle")
            .on("mouseover", handlePlotMouseover)
            .on("mouseleave", handlePlotMouseleave);

        let colorMap = () => {
            d3.selectAll(".Country")
            .transition()
            .duration(25)
            .style("fill", (d) => {
                return selectedCountries.includes(d.properties.name) ? selectedColor : unselectedColor;
            })
        };

        colorPlot = () => {
            d3.selectAll("circle")
            .transition()
            .duration(25)
            .style("fill", d => {
                if (selectedCountries.includes(d.data["Country_cleaned_name"].replace(/[$"]|\s+$/g, "").trim())) {
                return selectedColor;
                } else {
                return dotColor;
                }
            })
            .style("stroke", d => {
                if (selectedCountries.includes(d.data["Country_cleaned_name"].replace(/[$"]|\s+$/g, "").trim())) {
                return borderColor;
                } else {
                return null;
                }
            })
            .style("stroke-width", 1.5);
        };


        let xAxisScatter = (g) => g
            .attr("transform", `translate(0,${height - marginBottom})`)
            .call(d3.axisBottom(xScalePopulation));

        let widthScat = 800;
        let heightScat = 750;
        let radiusScat = 3;
        
        drawScat = () => {
            let svg3 = d3.select("#scat_plot")
            .attr("width", widthScat)
            .attr("height", heightScat)
            .attr("transform", `translate(0,${marginTop})`)
            .attr("viewBox", [0, 600, widthScat, heightScat])
            .attr("style", "max-width: 100%; height: auto;");

            svg3.append("g")
                .attr("transform", `translate(0,${heightScat - marginBottom})`)
                .call(d3.axisBottom(xScalePopulation).tickSizeOuter(0));
                

            svg3.append("g")
                .selectAll("dot")
                .data(Object.values(countriesData), { radius: radius * 2 + padding, x: d => xScalePopulation(d["Population"]), y: d => xScalePopulation(d["Population"]) })
                .enter()
                .append("circle")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", radius)
                .attr("fill", dotColor);
        }

        
    }

  </script>

</body>

</html>