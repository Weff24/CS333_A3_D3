<html>
<!DOCTYPE html>
<meta charset="utf-8">
<style>
  #world_map {
    border: solid 1px black;
    flex: 1;
  }

  .states {
    fill: #ccc;
    stroke: #fff;
  }

  .symbol {
    fill-opacity: .8;
    stroke: #fff;
  }

  .symbol:hover {
    fill: red;
  }

  div.tooltip {
    display: grid;
    align-content: center;
    position: absolute;
    text-align: center;
    width: 200px;
    height: 60px;
    font: 12px sans-serif;
    background: lightsteelblue;
    border: 0px;
    pointer-events: none;
  }
</style>

<body>
  <!--Rather than loading v3 or v4, loading individual modules to ensure compatibility with v4 functions (loads newest version of each)-->
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <!-- <script src="https://d3js.org/d3-geo.v1.min.js"></script> -->
  <!-- <script src="https://d3js.org/d3-selection.v1.min.js"></script> -->
  <!-- <script src="https://d3js.org/d3-array.v1.min.js"></script> -->
  <!-- <script src="http://d3js.org/topojson.v1.min.js"></script>
  <script src="https://d3js.org/d3-collection.v0.1.min.js"></script>
  <script src="https://d3js.org/d3-dispatch.v0.4.min.js"></script>
  <script src="https://d3js.org/d3-dsv.v0.3.min.js"></script>
  <script src="https://d3js.org/d3-request.v0.4.min.js"></script>
  <script src="https://d3js.org/d3-queue.v3.min.js"></script>-->
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
  <!-- <script>

    var width = 960,
      height = 500;

    var projection = d3.geoAlbersUsa();
    var path = d3.geoPath()
      .projection(projection);

    var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

    var tooltip = d3.select("body").append("div")
      .attr("class", "tooltip")
      .style("opacity", 0);


    // load up the json files, and when we're done, call ready
    d3.queue()
      .defer(d3_request.json, "states.json")
      .defer(d3_request.json, "us-state-centroids.json")
      .await(ready);

    // keep these around for later
    var us, centroid;

    var sizeSqrt, colorSqrt;

    function ready(error, u, c) {

      // store the values so we can use them later
      states = u
      centroid = c



      // draw the states
      svg.append("path")
        .attr("class", "states")
        .datum(topojson.feature(states, states.objects.usStates))
        .attr("d", path);


      // draw the symbols on top
      svg.selectAll(".symbol")
        .data(centroid.features.sort(function (a, b) { return b.properties.population - a.properties.population; }))
        .enter().append("path")
        .attr("class", "symbol")
        .attr("fill", "green")
        .attr("d", path.pointRadius(function (d) { return 10 }))
        .on("mouseover", function (d) {
          tooltip.style("opacity", .9);
          tooltip.html("Name: " + d.properties.name + " | Population: " + d.properties.population)
            .style("left", (d3.event.pageX) + "px")
            .style("top", (d3.event.pageY - 28) + "px");
        })
        .on("mouseout", function (d) {
          tooltip.style("opacity", 0);
        });

      colorSqrt = d3.scaleSqrt()
        .domain([0, d3.max(centroid.features, (function (d) { return d.properties.population; }))])
        .range(["green", "blue"]);

      sizeSqrt = d3.scaleSqrt()
        .domain([0, d3.max(centroid.features, (function (d) { return d.properties.population; }))])
        .range([5, 20]);

    }

    function recolor(color) {

      // grab the symbol objects and modify their color 
      // notice we don't need "enter" or "append" the objects are already there
      svg.selectAll(".symbol")
        .attr("fill", color)
        .attr("d", path.pointRadius(function (d) { return 10 })); //change size back if it has been altered
    }

    var sizePatt = RegExp("size");
    var colPatt = RegExp("color");

    function popToEncoding(encode) {
      var resultSize = sizePatt.test(encode);
      var resultCol = colPatt.test(encode);
      if (resultSize && resultCol) {
        //pop to size and color
        console.log("size and color");
        svg.selectAll(".symbol")
          .attr("fill", function (d) { return colorSqrt(d.properties.population); })
          .attr("d", path.pointRadius(function (d) { return sizeSqrt(d.properties.population); }));
      } else if (resultSize) {
        //pop to size
        svg.selectAll(".symbol")
          .attr("d", path.pointRadius(function (d) { return sizeSqrt(d.properties.population); }));
      } else { //color
        svg.selectAll(".symbol")
          .attr("fill", function (d) { return colorSqrt(d.properties.population); })

      }


    }
  </script> -->
  <div id="vis_container">
    <div>
      <tr>
        <td>
          <input type="Button" value="Clear Selections" onclick="resetSelection()" />
        </td>
      </tr>
    </div>

    <div>
      <svg id="world_map" width="800" height="350"></svg>
    </div>
    <div>
      <svg id="population_plot" class="brush_container" width="800" height="600"></svg>
    </div>
    <div>
      <svg id="scat_plot" width="800" height="350"></svg>
    </div>
  </div>




  <script>
    // The svg
    let svg = d3.select("#world_map");
    let width = +svg.attr("width");
    let height = +svg.attr("height");

    // Map and projection
    let path = d3.geoPath();
    let projection = d3.geoMercator()
      .scale(70)
      .center([0, 0]);
    // .translate([-width / 2, 0]);

    // Data and color scale
    let countriesData = {}
    let data = d3.map();
    let colorScale = d3.scaleThreshold()
      .domain([100000, 1000000, 10000000, 30000000, 100000000, 500000000])
      .range(d3.schemeBlues[7]);

    // Colors 
    let selectedColor = "#f25050";
    let unselectedColor = "#ECECEC";
    let hoverColor = "#2986CC";
    let dotColor = "#B5B5B5";
    let borderColor = "#3F3F3F";

    // Selected data
    let selectedCountries = [];

    // basic tooltip
    let tooltip = d3.select("body").append("div")
      .attr("class", "tooltip")
      .style("opacity", 0);

    // // Country Coordinates from countries of the world
    // let countryCoordinates = d3.map();
    // // Country Coordinates from countries of the world using alternative country names

    // let countryCoordinatesAlt = d3.map();


    // Load external data and boot
    d3.queue()
      .defer(d3.json, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson")
      // .defer(d3.csv, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world_population.csv", function (d) { data.set(d.code, +d.pop); })
      .defer(d3.csv, "countries of the world very very clean.csv", function (d) {
        let countryNames = d["Country"].replace(/[$"]|\s+$/g, "").trim()
        let countryAltNames = d["Country_cleaned_name"].replace(/[$"]|\s+$/g, "").trim()

        // countryCoordinates.set(countryNames, { latitude: +d.latitude, longitude: +d.longitude });
        // countryCoordinatesAlt.set(countryAltNames, { latitude: +d.latitude, longitude: +d.longitude });
        // console.log(d);
        countriesData[countryAltNames] = d;
      })
      .await(ready);

    let drawMap = null;
    let drawPopulationPlot = null;
    let colorPlot = null;
    let brushPopulation = this.brush;

    let resetSelection = () => {
      selectedCountries = [];

      d3.selectAll(".selection").style("display", "none");

      colorPlot();
      drawMap();
      drawPopulationPlot();
    }

    function ready(error, topojson) {
      // console.log(countriesData)

      let mouseOver = function (d) {

        tooltip.transition()
          .duration(200)
          .style("opacity", .9)
          .style("left", event.pageX + "px")
          .style("top", (event.pageY + 10) + "px");
        // tooltip.html(d.properties.name + "<br>Population: " + countriesData[d.countryAltNames]);
        if (Object.keys(countriesData).includes(d.properties.name)) {
          tooltip.html(d.properties.name //countriesData[d.properties.name].Country
            + "<br>Population: " + countriesData[d.properties.name]["Population"]
            + "<br>GDP Per Capita: $" + countriesData[d.properties.name]["GDP ($ per capita)"]
            + "<br>Literacy Rate: " + countriesData[d.properties.name]["Literacy (%)"].replace(",", ".") + "%");
        } else {
          tooltip.html(d.properties.name + "<br>No data (Country not in dataset)");
        }


        d3.selectAll(".Country")
          .transition()
          .duration(100)
          .style("fill", function (country) {
            return selectedCountries.includes(country.properties.name) ? selectedColor : unselectedColor;
          })
        // .style("stroke", function (country) {
        //   return selectedCountries.includes(country.properties.name) ? "black" : "grey";
        // });

        d3.select(this)
          .transition()
          .duration(100)
          .style("fill", hoverColor)
        // .style("stroke", function (country) {
        //   return selectedCountries.includes(country.properties.name) ? "black" : "grey";
        // });
      };

      let mouseLeave = function (d) {

        // Hide the tooltip 
        tooltip.transition()
          .duration(200)
          .style("opacity", 0);

        d3.selectAll(".Country")
          .transition()
          .duration(100)
          .style("fill", function (country) {
            return selectedCountries.includes(country.properties.name) ? selectedColor : unselectedColor;
          })
        // .style("stroke", function (country) {
        //   return selectedCountries.includes(country.properties.name) ? "black" : "grey";
        // });

        d3.select(this)
          .transition()
          .duration(100)
          .style("fill", function (country) {
            return selectedCountries.includes(country.properties.name) ? selectedColor : unselectedColor;
          })
        // .style("stroke", function (country) {
        //   return selectedCountries.includes(country.properties.name) ? "black" : "grey";
        // });
      };

      let mouseClick = function (d) {
        // Store the name of the selected country
        if (selectedCountries.includes(d.properties.name)) {
          // Remove the country from the list
          selectedCountries = selectedCountries.filter(country => country !== d.properties.name);
        } else {
          // Add the country to the list
          selectedCountries.push(d.properties.name);
        }

        // Reset the color of all countries
        d3.selectAll(".Country")
          .transition()
          .duration(100)
          .style("fill", function (country) {
            return selectedCountries.includes(country.properties.name) ? selectedColor : unselectedColor;
          })
        // .style("stroke", function (country) {
        //   return selectedCountries.includes(country.properties.name) ? "black" : "grey";
        // });

        d3.select(this)
          .transition()
          .duration(100)
          .style("fill", function (country) {
            return selectedCountries.includes(country.properties.name) ? selectedColor : hoverColor;
          })
        // .style("stroke", function (country) {
        //   return selectedCountries.includes(country.properties.name) ? "black" : "grey";
        // });

        colorPlot();
      };


      // Draw the map
      drawMap = () => {
        svg.select('g').remove();

        svg.append("g")
          .selectAll("path")
          .data(topojson.features)
          .enter()
          .append("path")
          // draw each country
          .attr("d", d3.geoPath()
            .projection(projection)
          )
          // set the color of each country
          .style("fill", unselectedColor)
          .style("stroke", borderColor)
          .attr("class", function (d) { return "Country" })
          .on("mouseover", mouseOver)
          .on("mouseleave", mouseLeave)
          .on("click", mouseClick);

        let zoom = d3.zoom()
          .scaleExtent([1, 12])
          .translateExtent([[0, 0], [width, height]])
          .on('zoom', () => {
            svg.selectAll('path').attr('transform', d3.event.transform);
            svg.attr('stroke-width', 1 / d3.event.transform.k);
          });
        svg.transition().duration(1000).call(zoom.transform, d3.zoomIdentity);
        svg.call(zoom);
      }

      // Draw population plot function
      let widthPlot = 800;
      let heightPlot = 750;
      let marginTop = 0;
      let marginRight = 20;
      let marginBottom = 20;
      let marginLeft = 20;
      let radius = 3;
      let padding = 2;
      let xScalePopulation = d3.scaleLog()
        .domain(d3.extent(Object.values(countriesData).map(d => +d["Population"])))
        .range([marginLeft, width - marginRight]);

      drawPopulationPlot = () => {
        let svg2 = d3.select("#population_plot")
          .attr("width", widthPlot)
          .attr("height", heightPlot)
          .attr("transform", `translate(0,${marginTop})`)
          .attr("viewBox", [0, 600, widthPlot, heightPlot])
          .attr("style", "max-width: 100%; height: auto;");

        svg2.append("g")
          .attr("transform", `translate(0,${heightPlot - marginBottom})`)
          .call(d3.axisBottom(xScalePopulation).ticks(5, ",.0f").tickSize(10));

        // Append x-axis label
        svg2.append("text")
          .attr("transform", `translate(${widthPlot / 2},${heightPlot + 20})`) // Adjust the position as needed
          .style("text-anchor", "middle")
          .text("Population");

        // Append title
        svg2.append("text")
          .attr("x", widthPlot / 2)
          .attr("y", `${heightPlot + 50}`) // Adjust the position as needed
          .style("font-size", "20px")
          .style("font-weight", "bold")
          .style("text-anchor", "middle")
          .text("Population Distribution by Country");

        svg2.append("g")
          .selectAll("dot")
          .data(dodge(Object.values(countriesData), { radius: radius * 2 + padding, x: d => xScalePopulation(d["Population"]) }))
          .enter()
          .append("circle")
          .attr("cx", d => d.x)
          .attr("cy", d => heightPlot - marginBottom - radius - padding - d.y)
          .attr("r", radius)
          .attr("fill", dotColor);

        function dodge(data, { radius = 1, x }) {
          const radius2 = radius ** 2;
          const circles = data.map((d, i, data) => ({ x: +xScalePopulation(d["Population"]), data: d })).sort((a, b) => a.x - b.x);
          // circles.forEach(circle => {
          //   console.log(circle);
          // });
          const epsilon = 1e-3;
          let head = null, tail = null;

          // Returns true if circle âŸ¨x,yâŸ© intersects with any circle in the queue.
          function intersects(x, y) {
            let a = head;
            while (a) {
              if (radius2 - epsilon > (a.x - x) ** 2 + (a.y - y) ** 2) {
                return true;
              }
              a = a.next;
            }
            return false;
          }

          // Place each circle sequentially.
          for (const b of circles) {
            // Remove circles from the queue that canâ€™t intersect the new circle b.
            while (head && head.x < b.x - radius2) head = head.next;

            // Choose the minimum non-intersecting tangent.
            if (intersects(b.x, b.y = 0)) {
              let a = head;
              b.y = Infinity;
              do {
                let y = a.y + Math.sqrt(radius2 - (a.x - b.x) ** 2);
                if (y < b.y && !intersects(b.x, y)) b.y = y;
                a = a.next;
              } while (a);
            }

            // Add b to the queue.
            b.next = null;
            if (head === null) head = tail = b;
            else tail = tail.next = b;
          }
          return circles;
        }
      }

      // Draw map and plots
      drawMap();
      drawPopulationPlot();


      // 
      // Brushing and Linking
      //
      let colorMap = () => {
        d3.selectAll(".Country")
          .transition()
          .duration(25)
          .style("fill", (d) => {
            return selectedCountries.includes(d.properties.name) ? selectedColor : unselectedColor;
          })
      };

      colorPlot = () => {
        d3.selectAll("circle")
          .transition()
          .duration(25)
          .style("fill", d => {
            if (selectedCountries.includes(d.data["Country_cleaned_name"].replace(/[$"]|\s+$/g, "").trim())) {
              return selectedColor;
            } else {
              return dotColor;
            }
          })
          .style("stroke", d => {
            if (selectedCountries.includes(d.data["Country_cleaned_name"].replace(/[$"]|\s+$/g, "").trim())) {
              return borderColor;
            } else {
              return null;
            }
          })
          .style("stroke-width", 1.5);
      };

      brushPopulation = d3.brushX()
        .extent([[0, 0], [widthPlot, heightPlot]])
        .on("brush end", (event) => {
          if (event.selection === null) {
            selectedCountries = [];
          } else {
            const [x0, x1] = d3.event.selection;
            selectedCountries = Object.values(countriesData).filter(d => {
              return x0 <= xScalePopulation(+d["Population"]) &&
                x1 >= xScalePopulation(+d["Population"]);
            }).map(d => d["Country_cleaned_name"].replace(/[$"]|\s+$/g, "").trim());
          }
          colorPlot();
          colorMap();
        });

      let xAxisScatter = (g) => g
        .attr("transform", `translate(0,${height - marginBottom})`)
        .call(d3.axisBottom(xScalePopulation));
      // .selectAll("text.title")
      // .data([1])
      // .join("text")
      // .attr("class", "title")
      // .attr("font-family", "sans-serif")
      // .attr("font-size", 10)
      // .attr("y", -8)
      // .attr("fill", "currentColor")
      // .attr("x", chartWidth - 98)
      // .text("Fertility Rate (children per woman)");

      let makePopulationPlot = (circlesContainer) => {
        circlesContainer.selectAll(".brush_container")
          .data([1])
          .enter()
          .append("g")
          .attr("class", "brushContainer")
          .call(brushPopulation);

        // circlesContainer.selectAll("circle.dot")
        //   .data(countriesData, d => d["Country_cleaned_name"]) // <-- provide a ðŸ”‘ key function for joining data to SVG elements
        //   //     this key function is needed for proper animation, see https://observablehq.com/@philippkoytek/d3-part-3-selection-join-explained
        //   .enter()
        //   .append("circle")
        //   // .sort((a, b) => b.pop - a.pop)    // sort the data so that big bubbles are in the background
        //   .attr("class", "dot")
        // .on("click", (event, d) => {
        //   if (d.country === selectedCountry) {
        //     let selectedCountry = null;
        //   } else {
        //     let selectedCountry = d.country;
        //   }
        // })
        // .attr("fill", d => {
        //   if (d.country === selectedCountry) {
        //     return "#3484c7";
        //   } else if (brushedCountries.includes(d.country)) {
        //     return "#573B9F";
        //   } else {
        //     return "lightgrey";
        //   }
        // })
        // .transition().duration(1000) // <-- animate the update of the following attributes (cx, cy, r, fill)
        // .attr("cx", d => xScaleScatter(d.fertility))
        // .attr("cy", d => yScaleScatter(d.life_expect))
        // .attr("r", d => radiusScale(d.pop));

        // circlesContainer.selectAll("g.yAxis")
        //   .data([1])
        //   .join("g")
        //   .attr("class", "yAxis")
        //   .call(yAxisScatter);

        // circlesContainer.selectAll("g.xAxis")
        //   .data([1])
        //   .enter()
        //   .append("g")
        //   .attr("class", "xAxis")
        //   .call(xAxisScatter);

        // circlesContainer.selectAll("text.chartTitle")
        //   .data([1])
        //   .join("text")
        //   .attr("class", "chartTitle")
        //   .attr("font-family", "sans-serif")
        //   .attr("font-size", 14)
        //   .attr("fill", "currentColor")
        //   .attr("y", 30)
        //   .attr("x", 10)
        //   .text(`Average Fertility & Life Expectancy by Country in ${year}`);
      }

      // let makeLineChart = (linesContainer) => {
      //   linesContainer.selectAll("path.line")
      //     .data(linesDataByCountry)
      //     .join("path")
      //     .attr("class", "line")
      //     .attr("d", lineGenerator)
      //     .attr("stroke", d => {
      //       if (d[0].country === selectedCountry) {
      //         return "#3484c7";
      //       } else if (brushedCountries.includes(d[0].country)) {
      //         return "#573B9F";
      //       } else {
      //         return "lightgrey"
      //       }
      //     })
      //     .attr("stroke-width", 2)
      //     .attr("opacity", 0.8)
      //     .attr("fill", "none");

      // const chartsContainer = d3.select("#vis_container");
      d3.select("#population_plot")
        .call(makePopulationPlot);

      // chartsContainer.select("#world_map")
      //   .call(makeWorldMap);






      // Draw population plot function
      let widthScat = 800;
      let heightScat = 750;
      // let marginTop = 0;
      // let marginRight = 20;
      // let marginBottom = 20;
      // let marginLeft = 20;
      let radiusScat = 3;
      // let padding = 2;
      // let xScalePopulation = d3.scaleLog()
      //   .domain(d3.extent(Object.values(countriesData).map(d => +d["Population"])))
      //   .range([marginLeft, width - marginRight]);

      drawScat = () => {
        let svg3 = d3.select("#scat_plot")
          .attr("width", widthScat)
          .attr("height", heightScat)
          .attr("transform", `translate(0,${marginTop})`)
          .attr("viewBox", [0, 600, widthScat, heightScat])
          .attr("style", "max-width: 100%; height: auto;");

          svg3.append("g")
            .attr("transform", `translate(0,${heightScat - marginBottom})`)
            .call(d3.axisBottom(xScalePopulation).tickSizeOuter(0));

        //   // Append x-axis label
        //   svg2.append("text")
        //     .attr("transform", `translate(${widthPlot / 2},${heightPlot + 20})`) // Adjust the position as needed
        //     .style("text-anchor", "middle")
        //     .text("Population");

        //   // Append title
        //   svg2.append("text")
        //     .attr("x", widthPlot / 2)
        //     .attr("y", `${heightPlot + 50}`) // Adjust the position as needed
        //     .style("font-size", "20px")
        //     .style("font-weight", "bold")
        //     .style("text-anchor", "middle")
        //     .text("Population Distribution by Country");

          svg3.append("g")
            .selectAll("dot")
            .data(Object.values(countriesData), { radius: radius * 2 + padding, x: d => xScalePopulation(d["Population"]), y: d => xScalePopulation(d["Population"]) })
            .enter()
            .append("circle")
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("r", radius)
            .attr("fill", dotColor);
      }
    }

  </script>


  <!-- <form>
    <table>
      <tr>
        <td>
          <input type="Button" value="Reset" onclick="recolor('green')" />
        </td>
        <td>
          <input type="Button" value="Map Population to Color" onclick="popToEncoding('color')" />
        </td>
        <td>
          <input type="Button" value="Map Population to Size" onclick="popToEncoding('size')" />
        </td>
        <td>
          <input type="Button" value="Map Population to Color and Size" onclick="popToEncoding('size_color')" />
        </td>
      </tr>
    </table>
  </form> -->

</body>

</html>