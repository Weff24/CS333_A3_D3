
          <!-- ====================== GDP PLOT STUFF BELOW ====================== -->
          <svg id="gdp_plot" class="brush_container" width="800" height="600">
            <rect id="gdp_rect" rx="4" ry="4" x="0" y="0" width="0" height="0" class="selection-rect"
              style="fill: rgba(185, 177, 177, 0.25); stroke: rgb(82, 82, 82); stroke-width: 2.5;">
            </rect>
          </svg>


// ====================== GDP PLOT ======================
d3.select("#gdp_plot rect").attr("width", 0);
d3.select("#gdp_plot rect").attr("height", 0);
drawGDPPlot();

// ====================== GDP PLOT STUFF BELOW ======================
if(name_of_plot != "gdp_plot"){
    d3.select("#gdp_plot rect").attr("width", 0);
    d3.select("#gdp_plot rect").attr("height", 0);
}

        // =========================================================================
        // ============================= GDP PLOT ==================================
        // =========================================================================

        // Draw gdp plot function
        let gdp_widthPlot = 450;
        let gdp_heightPlot = 250;
        let gdp_verticalOffset = 750;
        let gdp_marginTop = 0;
        let gdp_marginRight = 20;
        let gdp_marginBottom = 20;
        let gdp_marginLeft = 20;
        let gdp_radius = 4;
        let gdp_padding = 2;
        let xScaleGDP = d3.scaleLog()
          .domain(d3.extent(Object.values(countriesData).map(d => +d["GDP ($ per capita)"])))
          .range([gdp_marginLeft, width - gdp_marginRight]);

        drawGDPPlot = () => {
          let svg_gdp = d3.select("#gdp_plot")
            .attr("width", gdp_widthPlot)
            .attr("height", gdp_heightPlot)
            .attr("transform", `translate(0,${gdp_marginTop})`)
            .attr("viewBox", [0, 600, gdp_widthPlot, gdp_heightPlot])
            .attr("style", "max-width: 100%; height: auto;");

          svg_gdp.append("g")
            .attr("transform", `translate(0,${gdp_verticalOffset - gdp_marginBottom})`)
            .call(d3.axisBottom(xScaleGDP).ticks(5, ",.0f").tickSize(10));

          // Append x-axis label
          svg_gdp.append("text")
            .attr("transform", `translate(${gdp_widthPlot / 2},${gdp_verticalOffset + 20})`) // Adjust the position as needed
            .style("text-anchor", "middle")
            .text("GDP");

          // Append title
          svg_gdp.append("text")
            .attr("x", gdp_widthPlot / 2)
            .attr("y", `${gdp_verticalOffset + 50}`) // Adjust the position as needed
            .style("font-size", "20px")
            .style("font-weight", "bold")
            .style("text-anchor", "middle")
            .text("GDP Distribution by Country");

          svg_gdp.append("g")
            .selectAll("dot")
            .data(dodge(Object.values(countriesData), { gdp_radius: gdp_radius * 2 + gdp_padding, x: d => xScaleGDP(d["GDP ($ per capita)"]) }))
            .enter()
            .append("circle")
            .attr("cx", d => d.x)
            .attr("cy", d => gdp_verticalOffset - gdp_marginBottom - gdp_radius - gdp_padding - d.y)
            .attr("r", gdp_radius)
            .attr("fill", dotColor);

          svg_gdp.call(d3.drag()
            .on("start", dragStart_gdp)
            .on("drag", dragMove_gdp)
            .on("end", dragEnd_gdp));

          function dodge(data, { gdp_radius = 1, x }) {
            const gdp_radius2 = gdp_radius ** 2;
            const circles = data.map((d, i, data) => ({ x: +xScaleGDP(d["GDP ($ per capita)"]), data: d })).sort((a, b) => a.x - b.x);
            // circles.forEach(circle => {
            //   console.log(circle);
            // });
            const epsilon = 1e-3;
            let head = null, tail = null;

            // Returns true if circle ⟨x,y⟩ intersects with any circle in the queue.
            function intersects(x, y) {
              let a = head;
              while (a) {
                if (gdp_radius2 - epsilon > (a.x - x) ** 2 + (a.y - y) ** 2) {
                  return true;
                }
                a = a.next;
              }
              return false;
            }

            // Place each circle sequentially.
            for (const b of circles) {
              // Remove circles from the queue that can’t intersect the new circle b.
              while (head && head.x < b.x - gdp_radius2) head = head.next;

              // Choose the minimum non-intersecting tangent.
              if (intersects(b.x, b.y = 0)) {
                let a = head;
                b.y = Infinity;
                do {
                  let y = a.y + Math.sqrt(gdp_radius2 - (a.x - b.x) ** 2);
                  if (y < b.y && !intersects(b.x, y)) b.y = y;
                  a = a.next;
                } while (a);
              }

              // Add b to the queue.
              b.next = null;
              if (head === null) head = tail = b;
              else tail = tail.next = b;
            }
            return circles;
          }
        }










        
        // ================== GDP PLOT BRUSHING AND LINKING =================
        
        // Declare rectElement_gdp outside the function
        var rectElement_gdp;


        var selectionRect_gdp = {
          element: null,
          originX: 0,
          originY: 0,
          currentX: 0,
          currentY: 0,

          setElement: function (ele) {
            this.element = ele;
          },

          init: function (newX, newY, xAxisOnly) {
            this.setElement(rectElement_gdp);
            this.originX = newX;
            this.originY = newY;
            this.update(newX, newY, xAxisOnly);
          },

          update: function (newX, newY, xAxisOnly) {
            this.currentX = newX;
            this.currentY = newY;

            var x = Math.min(this.currentX, this.originX);
            var y = Math.min(this.currentY, this.originY);
            var width = Math.abs(this.currentX - this.originX);
            var height = Math.abs(this.currentY - this.originY);

            // Set properties of the rectElement_gdp directly
            rectElement_gdp.attr("x", x);
            rectElement_gdp.attr("width", width);

            if (xAxisOnly) {
              // If only the X-axis is used, set a fixed height
              rectElement_gdp.attr("y", 600); // currently hard-coded in
              rectElement_gdp.attr("height", 130); // currently hard-coded in
            } else {
              // If both axes are used, update the width and height
              rectElement_gdp.attr("y", y);
              rectElement_gdp.attr("height", height);
            }
          },

          remove: function () {
            // No need to remove the rectElement_gdp since it's not created dynamically
            this.element = null;
          }
        };

        function dragStart_gdp() {
          var p = d3.mouse(this);
          selectionRect_gdp.init(p[0], p[1], true);
          clearOtherSelections("gdp_plot");
        }

        function dragMove_gdp() {

          var p = d3.mouse(this);

          // Update the selection box
          selectionRect_gdp.update(p[0], p[1], true);

          // Get the x-range of the selection box
          var xMin = Math.min(selectionRect_gdp.originX, selectionRect_gdp.currentX);
          var xMax = Math.max(selectionRect_gdp.originX, selectionRect_gdp.currentX);

          // Initialize a Map to store country names and their corresponding x-values
          let countryXMap = new Map();

          // Populate the countryXMap during the data loading phase
          Object.values(countriesData).forEach(function (country) {
            var countryName = country["Country_cleaned_name"].replace(/[$"]|\s+$/g, "").trim();
            var xValue = xScaleGDP(country["GDP ($ per capita)"]);
            countryXMap.set(countryName, xValue);
          });

          // Filter countries based on the x-range
          var selectedCountriesInBox_gdp = Object.values(countriesData).filter(function (country) {
            var x = xScaleGDP(country["GDP ($ per capita)"]);
            return x >= xMin && x <= xMax;
          });

          // Update selectedCountries array
          selectedCountries = selectedCountriesInBox_gdp.map(function (country) {
            return country["Country_cleaned_name"].replace(/[$"]|\s+$/g, "").trim();
          });

          //console.log(selectedCountries);

          // Update the color based on the selection
          colorMap();
          colorPlot();
          // drawMap();
        }

        function dragEnd_gdp() {
          console.log("dragEnd_gdp");
        }










        
        // ====================== GDP PLOT BRUSHING SELECTION ======================
        function displayRect_gdp() {
          // Select the rect element inside #selection_box
          rectElement_gdp = d3.select("#gdp_plot rect#gdp_rect");

          if (rectElement_gdp.empty()) {
            console.error("No rect element found inside #gdp_plot");
            return;
          }

          // Attach drag behavior to the existing rectElement_gdp
          rectElement_gdp
            .call(d3.drag().on("start", dragStart_gdp).on("drag", dragMove_gdp).on("end", dragEnd_gdp));

          // Set the rectElement_gdp to be the target for selectionRect_gdp
          selectionRect_gdp.setElement(rectElement_gdp);
        }

        // Call the displayRect function to initiate the rectangle
        displayRect_gdp();